"""
1463번 : 1로 만들기
문제를 읽어보면 알겠지만 연산의 사용되는 횟수의 최솟값을 구하는 문제이다
단 3가지 규칙을 이용하여 횟수를 연산하기 때문에 숫자가 커질수록 이전 숫자의 +1 한 연산이 계속적으로 반복된다
예로들어 10을 만들기까지 최소가 1*3*3+1 = 10 하여서 3번이 최소라면 20은 10*2로 이전에 구해 놓은 3번+1번 = 4번으로 수행된다
하지만 주의할 점이 조건식 순서대로 조건을 걸면 잘못해서 10을 (1*2*2+1)*2 = 10해서 4로 저장하여 최소값이 아니게 된다
저 부분에 대해 주의하여 조건식을 걸면 dynamic programming을 이용하여 풀수 있다
조건식은 (현재숫자의 -1한 숫자 연산횟수에 +1한 값)과 (현재숫자가 나눠지면 나눈 숫자의 연산횟수에 +1한 값) 이 두 값을 비교하였을 때
더 짧은 친구를 메모리에 저장시키면 되고 bottom-up 방식의 dynamic으로 구현하였다
"""

# 숫자 입력받기
num = int(input())

# 숫자 크기+1만큼 리스트 만들기 -> 현재숫자를 index랑 동일하게 사용하기 위해 +1함
mem = [0 for i in range(num+1)]

# 2부터 연산을 시작하면 됨
for i in range(2,num+1):
    if i % 3 == 0:
        # 현재 값을 3으로 나눈 숫자연산횟수에 +1한 횟수와 나누지 않고 -1한 숫자연산횟수에 +1한 횟수를 비교하여 짧은 놈 저장
        # 그게 아니라면 그냥 나눈 숫자연산횟수에 +1한 횟수를 저장, 아래의 경우들도 마찬가지
        if mem[int(i / 3)] + 1 > mem[i-1] + 1:
            mem[i] = mem[i-1] + 1
        else:
            mem[i] = mem[int(i / 3)] + 1
    elif i % 2 == 0:
        if mem[int(i / 2)] + 1 > mem[i - 1] + 1:
            mem[i] = mem[i - 1] + 1
        else:
            mem[i] = mem[int(i / 2)] + 1
    else:
        mem[i] = mem[i - 1] + 1
print(mem[num])
